name: Response Grader

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to grade'
        required: true
        type: string

jobs:
  grade-response:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Check if this is a query response
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = context.issue?.number || parseInt('${{ inputs.issue_number }}');
            
            if (!issueNumber) {
              console.log('No issue number found');
              return false;
            }
            
            // Get the issue details
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            // Check if this is a query issue
            const labels = issue.data.labels.map(l => l.name);
            const isQueryIssue = labels.includes('query-request') || labels.includes('batch-query');
            
            if (!isQueryIssue) {
              console.log('Not a query issue, skipping');
              return false;
            }
            
            // Note: We don't skip if already graded - there might be new responses to grade
            // The extract step will determine if there are any ungraded responses
            
            // Check if response has been posted
            const hasCompleted = labels.includes('completed');
            
            // For workflow_dispatch, always process
            if (context.eventName === 'workflow_dispatch') {
              core.setOutput('should_grade', 'true');
              core.setOutput('issue_number', issueNumber);
              return true;
            }
            
            // For issue_comment, check if the comment is the response
            if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment;
              const isBot = comment.user.type === 'Bot' || comment.user.login.includes('[bot]');
              const containsResponse = comment.body.includes('Query Processing Complete') || 
                                      comment.body.includes('ChatGPT Response');
              
              if (isBot && containsResponse) {
                core.setOutput('should_grade', 'true');
                core.setOutput('issue_number', issueNumber);
                return true;
              }
            }
            
            console.log('Conditions not met for grading');
            return false;
      
      - name: Checkout repository
        if: steps.check.outputs.should_grade == 'true'
        uses: actions/checkout@v6
      
      - name: Set up Python
        if: steps.check.outputs.should_grade == 'true'
        uses: actions/setup-python@v6
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        if: steps.check.outputs.should_grade == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install openai
      
      - name: Extract query and response
        if: steps.check.outputs.should_grade == 'true'
        id: extract
        env:
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            
            // Get issue details
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            // Extract query from issue body
            let query = '';
            const body = issue.data.body || '';
            
            // Try to extract query between **Query:** and ---
            const queryMatch = body.match(/\*\*Query:\*\*\s*\n([\s\S]*?)\n---/);
            if (queryMatch) {
              query = queryMatch[1].trim();
            } else {
              // Fallback: use title
              query = issue.data.title.replace(/^Query:\s*/, '');
            }
            
            console.log(`Extracted query: ${query}`);
            core.setOutput('query', query);
            
            // Get all comments on the issue
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100
            });
            
            // Find ALL response comments and check which ones are already graded
            const responses = [];
            
            for (const comment of comments.data) {
              const commentBody = comment.body;
              
              if (commentBody.includes('Query Processing Complete') || 
                  commentBody.includes('ChatGPT Response')) {
                
                // Extract ChatGPT response
                const responseMatch = commentBody.match(/### ðŸ¤– ChatGPT Response\s*\n\n([\s\S]*?)\n\n---/);
                let responseText = '';
                if (responseMatch) {
                  responseText = responseMatch[1].trim();
                }
                
                // Extract MorphoSource results
                const resultsMatch = commentBody.match(/### ðŸ“Š MorphoSource API Results\s*\n\n```json\s*\n([\s\S]*?)\n```/);
                let morphosourceResults = '{}';
                if (resultsMatch) {
                  morphosourceResults = resultsMatch[1].trim();
                }
                
                if (responseText) {
                  responses.push({
                    commentId: comment.id,
                    responseText: responseText,
                    morphosourceResults: morphosourceResults
                  });
                }
              }
            }
            
            if (responses.length === 0) {
              console.log('No responses found yet, skipping grading');
              core.setOutput('has_response', 'false');
              return;
            }
            
            console.log(`Found ${responses.length} response(s) to grade`);
            
            // Check which responses have already been graded by looking for grade comments
            const gradedCommentIds = new Set();
            for (const comment of comments.data) {
              const commentBody = comment.body;
              if (commentBody.includes('Response Grade:') && commentBody.includes('Graded by automated response evaluation system')) {
                // Extract which response was graded (if we can identify it)
                // For now, we'll mark the workflow to track graded responses
                const match = commentBody.match(/<!-- graded-comment-id: (\d+) -->/);
                if (match) {
                  gradedCommentIds.add(parseInt(match[1]));
                }
              }
            }
            
            // Filter out already graded responses
            const ungradedResponses = responses.filter(r => !gradedCommentIds.has(r.commentId));
            
            if (ungradedResponses.length === 0) {
              console.log('All responses have already been graded');
              core.setOutput('has_response', 'false');
              return;
            }
            
            console.log(`Found ${ungradedResponses.length} ungraded response(s)`);
            core.setOutput('has_response', 'true');
            core.setOutput('response_count', ungradedResponses.length.toString());
            
            // Write all ungraded responses to files for Python script
            fs.writeFileSync('responses.json', JSON.stringify(ungradedResponses, null, 2));
            
            console.log('Extracted responses and results for grading');
      
      - name: Grade all responses
        if: steps.check.outputs.should_grade == 'true' && steps.extract.outputs.has_response == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          QUERY: ${{ steps.extract.outputs.query }}
        run: |
          # Grade each response separately
          python3 << 'EOF'
          import json
          import os
          import sys
          
          # Import the grade_response function
          sys.path.insert(0, '.github/scripts')
          from grade_response import grade_response
          
          query = os.environ['QUERY']
          
          # Read all responses
          with open('responses.json', 'r') as f:
              responses = json.load(f)
          
          # Grade each response
          all_grades = []
          for i, response_data in enumerate(responses):
              print(f"\n{'='*60}")
              print(f"Grading response {i+1} of {len(responses)}")
              print(f"{'='*60}")
              
              response_text = response_data['responseText']
              morphosource_results = json.loads(response_data['morphosourceResults'])
              comment_id = response_data['commentId']
              
              grade_result = grade_response(query, response_text, morphosource_results)
              grade_result['comment_id'] = comment_id
              all_grades.append(grade_result)
          
          # Write all grades to file
          with open('all_grades.json', 'w') as f:
              json.dump(all_grades, f, indent=2)
          
          print(f"\nâœ“ Graded {len(all_grades)} response(s)")
          EOF
      
      - name: Post grades to issue
        if: steps.check.outputs.should_grade == 'true' && steps.extract.outputs.has_response == 'true'
        env:
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            
            if (!fs.existsSync('all_grades.json')) {
              console.log('No grade results file found');
              return;
            }
            
            const allGrades = JSON.parse(fs.readFileSync('all_grades.json', 'utf8'));
            
            console.log(`Posting ${allGrades.length} grade(s) to issue #${issueNumber}`);
            
            let allSuccessful = true;
            let highestGradeLabel = 'grade-low';
            
            // Post a grade comment for each response
            for (let i = 0; i < allGrades.length; i++) {
              const gradeData = allGrades[i];
              
              if (gradeData.status !== 'success') {
                console.log(`Grading failed for response ${i+1}:`, gradeData.message);
                
                // Post error comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `âš ï¸ **Grading Error (Response ${i+1})**\n\nFailed to grade the response: ${gradeData.message}`
                });
                allSuccessful = false;
                continue;
              }
              
              // Format grade emoji
              const grade = gradeData.grade;
              let gradeEmoji = 'âŒ';
              let gradeLabel = 'grade-low';
              if (grade >= 80) {
                gradeEmoji = 'ðŸŒŸ';
                gradeLabel = 'grade-excellent';
              } else if (grade >= 60) {
                gradeEmoji = 'âœ…';
                gradeLabel = 'grade-good';
              } else if (grade >= 40) {
                gradeEmoji = 'âš ï¸';
                gradeLabel = 'grade-fair';
              }
              
              // Update highest grade label
              const gradeValues = {
                'grade-excellent': 4,
                'grade-good': 3,
                'grade-fair': 2,
                'grade-low': 1
              };
              if (gradeValues[gradeLabel] > gradeValues[highestGradeLabel]) {
                highestGradeLabel = gradeLabel;
              }
              
              // Build comment with grade
              const responseNumber = allGrades.length > 1 ? ` (Response ${i+1}/${allGrades.length})` : '';
              const commentBody = `## ${gradeEmoji} Response Grade${responseNumber}: ${grade}/100\n\n` +
                `### Breakdown\n\n` +
                `| Criterion | Score |\n` +
                `|-----------|-------|\n` +
                `| Query Formation | ${gradeData.breakdown.query_formation}/25 |\n` +
                `| Results Quality | ${gradeData.breakdown.results_quality}/25 |\n` +
                `| Response Accuracy | ${gradeData.breakdown.response_accuracy}/25 |\n` +
                `| Response Completeness | ${gradeData.breakdown.response_completeness}/25 |\n` +
                `| **Total** | **${grade}/100** |\n\n` +
                `### Evaluation\n\n` +
                `**Strengths:** ${gradeData.strengths}\n\n` +
                `**Areas for Improvement:** ${gradeData.weaknesses}\n\n` +
                `**Reasoning:** ${gradeData.reasoning}\n\n` +
                `---\n\n` +
                `**Results Found:** ${gradeData.result_count || 0} specimens\n\n` +
                `*Graded by automated response evaluation system*\n` +
                `<!-- graded-comment-id: ${gradeData.comment_id} -->`;
              
              // Post comment with grade
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: commentBody
              });
              
              console.log(`âœ“ Posted grade ${grade}/100 for response ${i+1}/${allGrades.length}`);
            }
            
            // Add 'graded' label and appropriate grade label based on highest grade
            const currentLabels = (await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            })).data.labels.map(l => l.name);
            
            const newLabels = [...currentLabels.filter(l => !l.startsWith('grade-')), 'graded', highestGradeLabel];
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: newLabels
            });
            
            console.log(`âœ“ Added 'graded' and '${highestGradeLabel}' labels to issue #${issueNumber}`);
      
      - name: Summary
        if: steps.check.outputs.should_grade == 'true' && steps.extract.outputs.has_response == 'true'
        env:
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          if [ -f all_grades.json ]; then
            RESPONSE_COUNT=$(jq '. | length' all_grades.json)
            echo "## Response Grading Complete âœ“" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Issue:** #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
            echo "**Responses Graded:** $RESPONSE_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Show grades for each response
            for i in $(seq 0 $((RESPONSE_COUNT - 1))); do
              GRADE=$(jq -r ".[$i].grade // 0" all_grades.json)
              echo "- Response $((i + 1)): **$GRADE/100**" >> $GITHUB_STEP_SUMMARY
            done
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "View the full grade breakdown on the issue." >> $GITHUB_STEP_SUMMARY
          fi
